/**
 * ClusteringService
 * Groups similar chunks into clusters
 */

import { SimilarityService } from "./similarity-service";

export interface ChunkWithEmbedding {
  id: string;
  embedding: number[];
  text: string;
  status: string;
  confidenceScore?: number;
  usageCount?: number;
}

export interface Cluster {
  id: string;
  chunkIds: string[];
  canonicalChunkId: string | null;
  conceptSummary: string | null;
}

export class ClusteringService {
  /**
   * Create clusters from chunks based on similarity
   * Auto-creates clusters when â‰¥ 2 chunks exceed near-duplicate threshold
   */
  static createClusters(
    chunks: ChunkWithEmbedding[],
    options: {
      nearDuplicateThreshold?: number;
      minClusterSize?: number;
    } = {}
  ): Map<string, Cluster> {
    const {
      nearDuplicateThreshold = 0.85,
      minClusterSize = 2,
    } = options;

    const clusters = new Map<string, Cluster>();
    const processed = new Set<string>();
    let clusterCounter = 0;

    for (let i = 0; i < chunks.length; i++) {
      if (processed.has(chunks[i].id)) continue;

      const currentChunk = chunks[i];
      const similarChunks: ChunkWithEmbedding[] = [currentChunk];

      // Find all similar chunks
      for (let j = i + 1; j < chunks.length; j++) {
        if (processed.has(chunks[j].id)) continue;

        const similarity = SimilarityService.cosineSimilarity(
          currentChunk.embedding,
          chunks[j].embedding
        );

        if (similarity >= nearDuplicateThreshold) {
          similarChunks.push(chunks[j]);
          processed.add(chunks[j].id);
        }
      }

      // Create cluster if we have enough chunks
      if (similarChunks.length >= minClusterSize) {
        const clusterId = `cluster_${++clusterCounter}`;
        const canonicalChunkId = this.selectCanonicalChunk(similarChunks);

        clusters.set(clusterId, {
          id: clusterId,
          chunkIds: similarChunks.map(c => c.id),
          canonicalChunkId,
          conceptSummary: null, // Will be generated by AI later
        });

        processed.add(currentChunk.id);
      }
    }

    return clusters;
  }

  /**
   * Select canonical chunk based on:
   * - approved status
   * - higher confidenceScore
   * - higher usageCount
   * - clearer language (shorter, simpler sentences)
   */
  private static selectCanonicalChunk(
    chunks: ChunkWithEmbedding[]
  ): string {
    // Sort by priority
    const sorted = [...chunks].sort((a, b) => {
      // Priority 1: Approved status (if status field indicates this)
      const aApproved = a.status === "APPROVED" ? 1 : 0;
      const bApproved = b.status === "APPROVED" ? 1 : 0;
      if (aApproved !== bApproved) return bApproved - aApproved;

      // Priority 2: Confidence score
      const aConf = a.confidenceScore || 0;
      const bConf = b.confidenceScore || 0;
      if (Math.abs(aConf - bConf) > 0.01) return bConf - aConf;

      // Priority 3: Usage count
      const aUsage = a.usageCount || 0;
      const bUsage = b.usageCount || 0;
      if (aUsage !== bUsage) return bUsage - aUsage;

      // Priority 4: Simpler language (shorter, fewer sentences)
      const aComplexity = this.calculateComplexity(a.text);
      const bComplexity = this.calculateComplexity(b.text);
      return aComplexity - bComplexity;
    });

    return sorted[0].id;
  }

  /**
   * Calculate language complexity (lower = simpler)
   */
  private static calculateComplexity(text: string): number {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim());
    const words = text.split(/\s+/).filter(w => w.trim());
    const avgWordsPerSentence = sentences.length > 0 ? words.length / sentences.length : words.length;
    
    // Longer sentences and more words = higher complexity
    return avgWordsPerSentence * sentences.length;
  }

  /**
   * Detect conflicts within a cluster
   */
  static detectConflicts(
    chunks: ChunkWithEmbedding[],
    metadata: Array<{
      id: string;
      toneTags?: string[];
      channel?: string;
      status?: string;
    }>
  ): Array<{
    chunkId1: string;
    chunkId2: string;
    conflictType: "meaning" | "tone" | "channel" | "constraint";
    description: string;
    severity: "low" | "medium" | "high";
  }> {
    const conflicts: Array<{
      chunkId1: string;
      chunkId2: string;
      conflictType: "meaning" | "tone" | "channel" | "constraint";
      description: string;
      severity: "low" | "medium" | "high";
    }> = [];

    const metadataMap = new Map(metadata.map(m => [m.id, m]));

    for (let i = 0; i < chunks.length; i++) {
      for (let j = i + 1; j < chunks.length; j++) {
        const chunk1 = chunks[i];
        const chunk2 = chunks[j];
        const meta1 = metadataMap.get(chunk1.id);
        const meta2 = metadataMap.get(chunk2.id);

        // Check for tone conflicts
        if (meta1?.toneTags && meta2?.toneTags) {
          const toneConflict = this.detectToneConflict(meta1.toneTags, meta2.toneTags);
          if (toneConflict) {
            conflicts.push({
              chunkId1: chunk1.id,
              chunkId2: chunk2.id,
              conflictType: "tone",
              description: `Tone mismatch: ${meta1.toneTags.join(", ")} vs ${meta2.toneTags.join(", ")}`,
              severity: "medium",
            });
          }
        }

        // Check for channel conflicts
        if (meta1?.channel && meta2?.channel && meta1.channel !== meta2.channel) {
          conflicts.push({
            chunkId1: chunk1.id,
            chunkId2: chunk2.id,
            conflictType: "channel",
            description: `Channel mismatch: ${meta1.channel} vs ${meta2.channel}`,
            severity: "low",
          });
        }

        // Check for status conflicts (both approved but different)
        if (meta1?.status === "APPROVED" && meta2?.status === "APPROVED") {
          // This is a potential meaning conflict - both approved but in same cluster
          conflicts.push({
            chunkId1: chunk1.id,
            chunkId2: chunk2.id,
            conflictType: "meaning",
            description: "Two approved chunks in same cluster may contradict",
            severity: "high",
          });
        }
      }
    }

    return conflicts;
  }

  private static detectToneConflict(
    tags1: string[],
    tags2: string[]
  ): boolean {
    // Define conflicting tone pairs
    const conflicts = [
      ["formal", "casual"],
      ["playful", "serious"],
      ["confident", "humble"],
      ["bold", "reserved"],
    ];

    for (const [tag1, tag2] of conflicts) {
      if (
        (tags1.includes(tag1) && tags2.includes(tag2)) ||
        (tags1.includes(tag2) && tags2.includes(tag1))
      ) {
        return true;
      }
    }

    return false;
  }
}

